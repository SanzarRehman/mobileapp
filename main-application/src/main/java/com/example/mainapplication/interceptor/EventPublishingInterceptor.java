package com.example.mainapplication.interceptor;

import com.example.mainapplication.service.CustomServerEventPublisher;
import org.axonframework.eventhandling.EventMessage;
import org.axonframework.messaging.InterceptorChain;
import org.axonframework.messaging.MessageHandlerInterceptor;
import org.axonframework.messaging.unitofwork.UnitOfWork;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * Interceptor that publishes events to the custom axon server after they are applied.
 * This ensures all events generated by the main application are sent to the custom server
 * for centralized storage and distribution.
 */
@Component
public class EventPublishingInterceptor implements MessageHandlerInterceptor<EventMessage<?>> {

    private static final Logger logger = LoggerFactory.getLogger(EventPublishingInterceptor.class);
    
    private final CustomServerEventPublisher eventPublisher;

    @Autowired
    public EventPublishingInterceptor(CustomServerEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    @Override
    public Object handle(UnitOfWork<? extends EventMessage<?>> unitOfWork, InterceptorChain interceptorChain) throws Exception {
        // Process the event normally first
        Object result = interceptorChain.proceed();
        
        // After successful processing, publish to custom server
        EventMessage<?> eventMessage = unitOfWork.getMessage();
        
        try {
            logger.debug("Intercepted event: {}", eventMessage.getPayloadType().getSimpleName());
            eventPublisher.publishEvent(eventMessage);
        } catch (Exception e) {
            logger.error("Failed to publish event {} to custom server: {}", 
                        eventMessage.getIdentifier(), e.getMessage(), e);
            // Don't throw exception to avoid breaking the main event processing
        }
        
        return result;
    }
}